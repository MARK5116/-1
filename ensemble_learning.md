Boosting 、 GBDT、 Xgboost综合分析

https://www.cnblogs.com/csyuan/p/6537255.html

# 集成算法

集成学习（ensemble learning）通过构建并结合多个学习器来完成学习任务。具有更好的泛化能力。在集成学习中，主要分为bagging算法和boosting算法。

要想获得好的集成效果，个体学习器应该“好而不同”，个体学习器要有一定的准确性。

随着集成中个体分类器数目T的增大，集成的错误率将指数级下降，最终趋向0。

## 1. Boosting算法基本思路

提升方法思路：对于一个复杂的问题，将多个专家的判断进行适当的综合所得出的判断，要比任何一个专家单独判断好。每一步产生一个弱预测模型(如决策树)，并加权累加到总模型中，可以用于回归和分类问题；如果每一步的弱预测模型生成都是依据损失函数的梯度方向，则称之为梯度提升(Gradient boosting)。

梯度提升算法首先给定一个目标损失函数，它的定义域是所有可行的弱函数集合(基函数)；提升算法通过迭代的选择一个负梯度方向上的基函数来逐渐逼近局部极小值。这种在函数域的梯度提升观点对机器学习的很多领域有深刻影响。

提升的理论意义：如果一个问题存在弱分类器,则可以通过提升的办法得到强分类器。

# Xgboost算法

首先xgboost算法是boosting 算法的一种形式，他是一种集成学习算法对于boosting算法。。。。。



# Xgboost与GBDT的区别

链接：https://www.cnblogs.com/callyblog/p/9735530.html

- **基分类器的选择：**

  传统GBDT以CART作为基分类器，xgboost还支持线性分类器，这个时候xgboost相当于带L1和L2正则化项的逻辑斯蒂回归（分类问题）或者线性回归（回归问题）。

- **二阶泰勒展开：**

  传统GBDT在优化时只用到一阶导数信息，xgboost则对代价函数进行了二阶泰勒展开，同时用到了一阶和二阶导数。顺便提一下，xgboost工具支持自定义代价函数，只要函数可一阶和二阶求导。 GBDT和GBDT拟合的是都是残差。

- **方差-方差权衡：**

  xgboost在代价函数里加入了正则项，用于控制模型的复杂度。正则项里包含了树的叶子节点个数、每个叶子节点上输出的score的L2模的平方和。从Bias-variance tradeoff角度来讲，正则项降低了模型的variance，使学习出来的模型更加简单，防止过拟合，这也是xgboost优于传统GBDT的一个特性。 

- **Shrinkage（缩减）：**

  相当于学习速率（xgboost中的eta）。xgboost在进行完一次迭代后，会将叶子节点的权重乘上该系数，主要是为了削弱每棵树的影响，让后面有更大的学习空间。实际应用中，一般把eta设置得小一点，然后迭代次数设置得大一点。（补充：传统GBDT的实现也有学习速率） 

- **列抽样（column subsampling）：**

  xgboost借鉴了随机森林的做法，支持列抽样，我们会在同一层的结点分割前先随机选一部分特征，遍历的时候只用遍历这部分特征就行了，不需要便利全部特征，不仅能降低过拟合，还能减少计算，这也是xgboost异于传统gbdt的一个特性。

- **缺失值处理：**

  XGBoost考虑了训练数据为稀疏值的情况，可以为缺失值或者指定的值指定分支的默认方向，这能大大提升算法的效率，论文中“枚举”指的**不是枚举每个缺失样本在左边还是在右边**，而是枚举**缺失样本整体**在左边，还是在右边两种情况。分裂点还是只评估特征不缺失的样本，paper提到50倍。对于特征的值有缺失的样本，xgboost可以自动学习出它的分裂方向。 

- **XGBoost工具支持并行：**

  boosting不是一种串行的结构吗?怎么并行的？注意xgboost的并行不是tree粒度的并行，xgboost也是一次迭代完才能进行下一次迭代的（第t次迭代的代价函数里包含了前面t-1次迭代的预测值）。xgboost的并行是在特征粒度上的。我们知道，决策树的学习最耗时的一个步骤就是对特征的值进行排序（因为要确定最佳分割点），xgboost在训练之前，预先对数据进行了排序，然后保存为block结构，后面的迭代中重复地使用这个结构，大大减小计算量。这个block结构也使得并行成为了可能，在进行节点的分裂时，需要计算每个特征的增益，最终选增益最大的那个特征去做分裂，那么各个特征的增益计算就可以开多线程进行。

- **线程缓冲区存储：**

  按照特征列方式存储能优化寻找最佳的分割点，但是当以行计算梯度数据时会导致内存的不连续访问，严重时会导致cache miss，降低算法效率。paper中提到，可先将数据收集到线程内部的buffer（缓冲区），主要是结合多线程、数据压缩、分片的方法，然后再计算，提高算法的效率。

- **可并行的近似直方图算法：**

  树节点在进行分裂时，我们需要计算每个特征的每个分割点对应的增益，即用贪心法枚举所有可能的分割点。当数据无法一次载入内存或者在分布式情况下，贪心算法效率就会变得很低，所以xgboost还提出了一种可并行的近似直方图算法，用于高效地生成候选的分割点。大致的思想是根据百分位法列举几个可能成为分割点的候选者，然后从候选者中根据上面求分割点的公式计算找出最佳的分割点。